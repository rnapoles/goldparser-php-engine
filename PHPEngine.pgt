##TEMPLATE-NAME 'PHP OO Engine'
##LANGUAGE 'PHP'
##ENGINE-NAME 'PHP OO Engine'
##AUTHOR 'Reinier Nápoles Martínez'
##FILE-EXTENSION 'php'
##NOTES

The template was based on the Kessels engine.

This template creates a .php file for use by the PHP Engine.
The complete CGT (Compiled Grammar Table) is hardcoded into the .php
file, so initializing the engine is very fast (it does not have
to load the CGT file from disk).

This template creates the source for a bare-bones interpreter. The
resulting code is executable and will show the progress of the
interpreter as it executes an input script.

##END-NOTES
##ID-SEPARATOR '_'
##ID-SYMBOL-PREFIX 'Symbol'
##ID-RULE-PREFIX 'Rule'
##DELIMITER ','
<?php

/*
##PARAMETERS 
Grammar Name    : %Name% 
Version         : %Version% 
Author          : %Author% 
About           : %About 
Case Sensitive  : %CaseSensitive% 
Start Symbol    : %StartSymbol% 

Output File      : %OutputFile% 
Output File Base : %OutputFileBase% 
##END-PARAMETERS 

This file was generated by the Gold Parser.
The template is PHP OO Engine

*/

use Gold\Engine\ActionStruct;
use Gold\Engine\ContextStruct;
use Gold\Engine\DfaEdgeStruct;   
use Gold\Engine\DfaStateStruct;  
use Gold\Engine\GrammarStruct;   
use Gold\Engine\LalrStateStruct; 
use Gold\Engine\RuleStruct;      
use Gold\Engine\SymbolStruct;    
use Gold\Engine\TokenStackStruct;
use Gold\Engine\TokenStruct;     
use Gold\AbstractParser;

##PARAMETERS
class %OutputFileBase% extends AbstractParser {
##END-PARAMETERS

	function Run(){

		$Context = new ContextStruct();
		$Result = $this->Parse();

		/* Interpret the results. */
		if ($Result != self::PARSEACCEPT) {
		  $this->ShowErrorMessage($Result);
		} else {

			/* Initialize the Context. */
			$Context->Debug = $this->Debug;
			$Context->Indent = 0;
			$Context->ReturnValue = NULL;

			/* Start execution by calling the subroutine of the first Token on
			 the TokenStack. It's the "Start Symbol" that is defined in the
			 $Grammar-> 
			*/
			$fn = $this->RuleJumpTable[$this->FirstToken->ReductionRule];
			$this->$fn($this->FirstToken,$Context);
		}

	}

	function RuleTemplate(TokenStruct $Token,ContextStruct $Context) {
		
		$i = 0;

		/* Debugging: show the description of the rule. */
		if ($Context->Debug > 0) {
			$this->ShowIndent($Context->Indent);
			printf("Executing rule: %s\n",$this->Grammar->RuleArray[$Token->ReductionRule]->Description);
		}

		/* For all the sub-Tokens. */
		for ($i = 0; $i < $this->Grammar->RuleArray[$Token->ReductionRule]->SymbolsCount; $i++) {
			
			/* See if the Token is a Symbol or a Rule. */
			if ($Token->Tokens[$i]->ReductionRule < 0) {

				/* It's a Symbol. Make a copy of the Data. Most symbols are grammar,
					 for example '+', 'function', 'while', and such, and you won't
					 need to look at the Data. Other symbols are literals from the input
					 script, for example numbers, strings, variable names, and such. */
				if($Context->ReturnValue != NULL) unset($Context->ReturnValue);
				$Context->ReturnValue = $Token->Tokens[$i]->Data;
				//echo $Context->ReturnValue."\n";
				/* Debugging: show a description of the Symbol, and it's value. */
				if ($Context->Debug > 0) {
					$this->ShowIndent($Context->Indent + 1);
					printf("Token[%u] = Symbol('%s') = '%s'\n",$i,
					$this->Grammar->SymbolArray[$Token->Tokens[$i]->Symbol]->Name,
					$Context->ReturnValue);
				}

			} else {

				/* It's a rule. */

				/* Debugging: show a description of the rule. */
				if ($Context->Debug > 0) {
					$this->ShowIndent($Context->Indent + 1);
					printf("Token[%u] = Rule = %s\n",$i,
					$this->Grammar->RuleArray[$Token->Tokens[$i]->ReductionRule]->Description);
				}

				/* Call the rule's subroutine via the RuleJumpTable. */
				$Context->Indent = $Context->Indent + 1;
				$fn = $this->RuleJumpTable[$Token->Tokens[$i]->ReductionRule];
				$this->$fn($Token->Tokens[$i],$Context);
				$Context->Indent = $Context->Indent - 1;

				/* At this point you will probably want to save the Context->ReturnValue
					 somewhere. */

				/* Debugging: show the value that was returned by the rule's subroutine. */
				if ($Context->Debug > 0) {
					$this->ShowIndent($Context->Indent + 2);
					printf("Result value = %s\n",$Context->ReturnValue);
				}
			}
		}

	}

	/***** Rule subroutines *****************************************************/

##RULE-TABLE
##RULES
	/* 
		Symbol Count: %SymbolCount%
		%Description% 
	*/
	function %ID%(TokenStruct $Token,ContextStruct $Context) {
		//echo "Calling %ID%\n";
		
		/*
		//^ %Description%
		*/
		
		$this->RuleTemplate($Token,$Context); //Replace with your code
	}

##END-RULES
##END-RULE-TABLE

	public function initGrammar(){

##CHAR-SET-TABLE
##CHAR-SETS
		$GrammarCharset%Index%CharCount = %CharCount%;
		$GrammarCharset%Index% = array(
##CHARS
			%UnicodeIndex%,
##END-CHARS
			0
		);

##END-CHAR-SETS
##END-CHAR-SET-TABLE

##DFA-TABLE
##DFA-STATES
		$GrammarDfaEdgeArray%Index% = array(
##DFA-EDGES
			new DfaEdgeStruct(%Target%,$GrammarCharset%CharSetIndex%CharCount,$GrammarCharset%CharSetIndex%),
##END-DFA-EDGES
			new DfaEdgeStruct(-1,0,NULL)
		);

##END-DFA-STATES
##END-DFA-TABLE

##RULE-TABLE
##RULES
		$GrammarRuleSymbolArray%Index% = array(
##RULE-SYMBOLS
			%SymbolIndex%,
##END-RULE-SYMBOLS
			-1
		);

##END-RULES
##END-RULE-TABLE

##LALR-TABLE
##LALR-STATES
		$GrammarLalrActionArray%Index% = array(
##LALR-ACTIONS
			new ActionStruct(%SymbolIndex%,%Action%,%Value%),
##END-LALR-ACTIONS
			new ActionStruct(-1,-1,-1)
		);
##END-LALR-STATES
##END-LALR-TABLE

##SYMBOL-TABLE
		$GrammarSymbolArray = array(
##SYMBOLS
			/* %Value.Padded% */   
			new SymbolStruct(%Kind%,"%Name%")%Delimiter%
##END-SYMBOLS
		);
##END-SYMBOL-TABLE

##DFA-TABLE
		$GrammarDfaStateArray = array(
##DFA-STATES
			/* %Index% */    
			new DfaStateStruct(%AcceptIndex%,%EdgeCount%,$GrammarDfaEdgeArray%Index%),
##END-DFA-STATES
			new DfaStateStruct(-1,-1,NULL)
		);
##END-DFA-TABLE

##RULE-TABLE
		$GrammarRuleArray = array(
##RULES
			/* %Value.Padded% */
			new RuleStruct(%NonterminalIndex%,%SymbolCount%,$GrammarRuleSymbolArray%Index%,"%Description%")%Delimiter%
##END-RULES
		);
##END-RULE-TABLE

##LALR-TABLE
		$GrammarLalrStateArray = array(
##LALR-STATES
			/* %Index% */
			new LalrStateStruct(%ActionCount%,$GrammarLalrActionArray%Index%),
##END-LALR-STATES
			new LalrStateStruct(-1,NULL)
		);
##END-LALR-TABLE

		$this->Grammar = new GrammarStruct();

##PARAMETERS
		/* CaseSensitive */      
		$this->Grammar->CaseSensitive = %CaseSensitive%;
		/* InitialSymbol */
		$this->Grammar->InitialSymbol = %StartSymbol%;
##END-PARAMETERS
##DFA-TABLE
		/* InitialDfaState */
		$this->Grammar->InitialDfaState = %InitialState%;
##END-DFA-TABLE
##LALR-TABLE
		/* InitialLalrState */
		$this->Grammar->InitialLalrState = %InitialState%;
##END-LALR-TABLE
##SYMBOL-TABLE
		/* SymbolCount */        
		$this->Grammar->SymbolCount = %Count%;
		/* SymbolArray */        
		$this->Grammar->SymbolArray = $GrammarSymbolArray;
##END-SYMBOL-TABLE
##RULE-TABLE
		/* RuleCount */          
		$this->Grammar->RuleCount = %Count%;
		/* RuleArray */          
		$this->Grammar->RuleArray = $GrammarRuleArray;
##END-RULE-TABLE
##DFA-TABLE
		/* DfaStateCount */      
		$this->Grammar->DfaStateCount = %Count%;
		/* DfaArray */           
		$this->Grammar->DfaArray = $GrammarDfaStateArray;
##END-DFA-TABLE
##LALR-TABLE
		/* LalrStateCount */     
		$this->Grammar->LalrStateCount = %Count%;
		/* LalrArray */          
		$this->Grammar->LalrArray = $GrammarLalrStateArray;
##END-LALR-TABLE

##RULE-TABLE
		$this->RuleJumpTable = array(
##RULES
			/* %Index%. %Description% */
			'%ID%'%Delimiter%
##END-RULES
		);
##END-RULE-TABLE

	}

}

?>